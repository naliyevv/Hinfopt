function [ hinfnmin, mumin, info ] = hinfopt( sys, opt )
%
%% PURPOSE:
%
% To compute a parameter μ_* that minimizes the H-infinity norm of a 
% parameter-dependent transfer function of the form
%
%   H(s;μ) := C(μ)*(sE(μ) − A(μ))^(−1)*B(μ),                            (1)
%
% where
%
%   A(μ) = a_1(μ)*A_1 + ... + a_{κ_A}(μ)*A_{κ_A}, 
%   B(μ) = b_1(μ)*B_1 + ... + b_{κ_B}(μ)*B_{κ_B},                       (2)
%   C(μ) = c_1(μ)*C_1 + ... + c_{κ_C}(μ)*C_{κ_C}, 
%   E(μ) = e_1(μ)*E_1 + ... + e_{κ_E}(μ)*E_{κ_E},
%
% and a_j, b_j, c_j, e_j are scalar-valued real-analytic functions and A_j,
% B_j, C_j, and E_j are fixed matrices.
% It is assumed that μ is in a closed box domain D and that H(.;μ) is an 
% H-infinity function for all μ in D, meaning that H(.;μ) is analytic and 
% bounded in the open right complex half-plane. 
%
% ARGUMENTS
%
% Inputs:
%
% sys     : a struct containg the structural information of the function 
%           H(s;μ) specified as follows:
%    sys.A, sys.B, sys.C,  
%    sys.E                : arrays containing the matrices A_j, B_j, C_j,
%                           and E_j in (2), respectively. If κ_X is larger 
%                           than 1, i.e., the number of summands within the
%                           function X(μ) is larger than 1 and multiple 
%                           constant matrices X_1 to X_{κ_X} must be given,
%                           they must be stored in a cell array as 
%                           sys.X = { X_1, ..., X_{κ_X} }, where X is 
%                           either A, B, C, or E.  
%    sys.f.A, sys.f.B, 
%    sys.f.C, sys.f.E     : function handles specifying the functions 
%                           x_1, ..., x_{κ_X} stored in vector, i.e.,
%                           sys.f.X(k) = x_k, where x is either a, b, c, or
%                           e and X is either A, B, C, or E.                           
%    sys.fgname           : name of a function that returns L-infinity norm 
%                           of a transfer function of the form (1)-(2) and 
%                           its gradient for a particular parameter μ.
%                           fgname is specified as 
%                              [ f, g ] = fgname( mu, pars ),
%                           where
%                              * mu is the point μ;
%                              * pars contains the parameters of the
%                                function as follows:
%                                - pars.A, pars.B, pars.C, pars.E,
%                                  pars.f.A, pars.f.B, pars.f.C, and
%                                  pars.f.E contain the information for the 
%                                  input transfer function as described
%                                  above;
%                                - pars.method specifies the implementation
%                                  of the Boyd-Balakrishnan algorithm for 
%                                  computing the L-infinity norm as
%                                  follows:
%                                  = 0: use the FORTRAN routine AB13HD.f 
%                                       which is called by the gateway 
%                                       function generated by linorm_h.F;
%                                  = 1: use the function 'norm' of the
%                                       MATLAB Control System Toolbox 
%                                       (WARNING: This may not work, if the
%                                       input descriptor matrix pars.E is 
%                                       singular at μ.);
%                                  (default = 0);
%                              * f, g are the L-infinity norm and its 
%                                gradient at the point μ.          
% sys.bounds.lb, 
% sys.bounds.ub          : lower and upper bounds of the parameter box 
%                          domain D. Hereby, sys.bounds.lb(k) and
%                          sys.bounds.ub(k) are the bounds for the k-th
%                          parameter, respectively.
% opt     : Struct containing options (use default values if empty). The
%           following options can be specified:
%    opt.tolmu            : relative tolerance on the change of the optimal
%                           parameters between two consecutive iterations.
%                           If the computed optimal parameters between two
%                           consecutive iterations have relative distance
%                           less than opt.tolmu, then the algorithm is
%                           assumed to be converged (default = 1e-6).
%    opt.tolnorm          : relative tolerance on the change of the
%                           computed H-infinity norms between two 
%                           consecutive iterations. If the computed 
%                           H-infinity norms between two consecutive
%                           iterations have relative distance less than
%                           opt.tolnorm, then the algorithm is assumed to
%                           be converged (default = 1e-6).
%    opt.maxit 		      : maximum number of iterations allowed until 
%                           termination of the algorithm (default = 100).
%    opt.initialParams	  : a matrix that contains the initial parameters 
%                           and frequencies of the interpolation points.
%                           Hereby, opt.initialParams(1:end-1,k) contains
%                           the k-th initial parameter value and 
%                           opt.initialParams(end,k) contains the
%                           corresponding initial frequency. The vectors 
%                           opt.initialParams(1:end-1,k) must be in D for
%                           each k.
%    opt.initialFreqs	  : initial frequencies of the initial 
%                           interpolation points on the imaginary axis used
%                           for computing the H-infinity norm by 
%                           linorm_subsp.
%    opt.prtlevel         : specifies the print level as follows:
%                           = 0: return no information;
%                           = 1: return minimal information;
%                           = 2: return full information;
%                           (default = 0).
%    opt.boydbalak        : specifies which implementation of the
%                           Boyd-Balakrishnan algorithm is used for the
%                           computation of the L-infinity-norm of the
%                           reduced functions as follows:
%                           = 0: use the FORTRAN routine AB13HD.f which is
%                                called by the gateway function generated
%                                by linorm_h.F;
%                           = 1: use the function 'norm' of the MATLAB
%                                Control System Toolbox (WARNING: This may
%                                not work, if the reduced descriptor matrix
%                                pars.E is singular.);
%                           (default = 0).
%    opt.optmeth          : specifies the method used for the parameter
%                           optimization as follows:
%                           = 0: use GRANSO;
%                           = 1: use eigopt;
%                           (default = 0).
%    opt.gamma            : a global lower bound for the second derivative 
%                           of the the function μ -> ||Hr(.;μ)||_{oo}, 
%                           where Hr are the reduced transfer functions
%                           during the iteration. This option is only
%                           needed, if eigopt is used for the parameter
%                           optimization.
%    opt.biorth           : specifies which orthonormalization scheme is
%                           used as follows:
%                           = 0: the intermediate projection spaces
%                                contained in U and V are orthonormalized
%                                separately, i.e., U'*U = V'*V = eye(k) for
%                                some k;
%                           = 1: the intermediate projection spaces are
%                                bi-orthonormalized, i.e., U'*V = eye(k)
%                                for some k;
%                           (default = 0).
%    opt.orthtol          : relative truncation tolerance in svd for the 
%                           determination of an orthonormal basis of a
%                           subspace or bi-orthonormal bases of two
%                           subspaces (default = 1e-12).
%    opt.maxSing          : specifies how the projection spaces are
%                           constructed as follows:
%                           = 0: all the singular vectors of H(i*w;μ) at an 
%                                interpolation point (i*w,μ) are included
%                                in the updated projection spaces; 
%                           = 1: only the singular vectors corresponding to
%                                the largest singular value of H(i*w;μ) at
%                                an interpolation point (i*w,μ) are 
%                                included in the updated projection spaces;
%                           (default = 0).
%
% Outputs:
%   
% hinfnmin: H-infinity norm of the function H(s;μ_*) in (1) at the optimal
%           parameter μ_*.
% mumin   : Optimal paramter at which the minimal H-infinity norm value is
%           attained.
% info    : Struct which contains the following information:
%    info.time            : time needed to compute the result.
%    info.iterations      : number of iterations at termination of the
%                           algorithm.
%    info.finaltolmu      : relative distance of the variable mumin between
%                           the last two iterations before termination.
%    info.finaltolnorm    : relative distance of the variable hinfnmin
%                           between the last two iterations before
%                           termination.
%    info.termcrit        : specifies which termination criteria are
%                           satisfied as follows:
%                           = 0: both the optimal parameter mumin and the
%                                optimal H-infinity norm hinfnmin have
%                                converged;
%                           = 1: only the optimal parameter mumin has
%                                converged, but the optimal H-infinity norm
%                                may be inaccurate;
%                           = 2: only the optimal H-infinity norm hinfnmin
%                                has converged, but the optimal parameter
%                                may be inaccurate;
%                           = 3: the algorithm has terminated by reaching
%                                the maximum number of iterations.
%    info.error           : contains an error indicator as follows:
%                           = 0: return without an error;
%                           = 1: the maximum number of iterations 
%                                specified in opt.maxit has been exceeded.
%
% REFERENCES:
%
% [1] N. Aliyev, P. Benner, E. Mengi, and M. Voigt.
%     A subspace framework for H-infinity norm minimization. Submitted for
%     publication, 2019.
%
% AUTHORS:
%
% Nicat Aliyev and Emre Mengi, Koc University, Istanbul, Turkey.
%
% Matthias Voigt, Technische Universitaet Berlin, Institut fuer Mathematik,
% Berlin, Germany.
%
% 07/10/2018.
%
% REVISIONS:
%
% Emre Mengi, 10/2018.
% Matthias Voigt, 12/2018, 03/2019.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  HINFOPT 1.0 Copyright (C) 2019 Nicat Aliyev, Emre Mengi, Matthias Voigt 
%
%  This program is free software: you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation, either version 3 of the License, or
%  (at your option) any later version.
%
%  This program is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% SET OPTIONS AND CHECK ARGUMENTS.
%
% Start timing.
%
timehinfopt = tic;
warning( 'off', 'all' );
%
info.error = 0;
%
% tolmu: relative tolerance on the change of the optimal parameters between
%        two consecutive iterations. If the computed optimal parameters
%        between two consecutive iterations have relative distance less 
%        than opt.tolmu, then the algorithm is assumed to be converged.
%
if isfield( opt, 'tolmu' )
    tolmu = opt.tolmu;
else % default
    tolmu = 1e-6;
end
%
% tolnorm: relative tolerance on the change of the computed H-infinity 
%          norms between two consecutive iterations. If the computed 
%          H-infinity norms between two consecutive iterations have
%          relative distance less than opt.tolnorm, then the algorithm is
%          assumed to be converged.
%
if isfield( opt, 'tolnorm' )
    tolnorm = opt.tolnorm;
else % default
    tolnorm = 1e-6;
end
%
% maxit: maximum number of iterations allowed until termination of the 
%        algorithm.
%
if isfield( opt, 'maxit' )
    maxit = opt.maxit;
else % default
    maxit = 100;
end
%
% boydbalak: specifies which implementation of the Boyd-Balakrishnan 
%            algorithm is used for the computation of the L-infinity-norm
%            of the reduced functions.
%
if isfield( opt, 'boydbalak' )
    boydbalak = opt.boydbalak;
else % default
    boydbalak = 0;
end
%
% optmeth: specifies the method used for the parameter optimization.
%
if isfield( opt, 'optmeth' )
    optmeth = opt.optmeth;
else % default
    optmeth = 0;
end
%
% gamma: a global lower bound for the second derivative of the the function
%        μ -> ||Hr(.;μ)||_{oo}, where Hr are the reduced transfer functions
%        during the iteration. This option is only needed, if eigopt is 
%        used for the parameter optimization.
%
if optmeth == 1
    if isfield( opt, 'gamma' )
        gamma = opt.gamma;
    else
        error( [ 'The argument opt.gamma must be specified when ', ...
            'using eigopt.' ] );
    end
end
%
% initialParams: a matrix that contains the initial parameters and
%                frequencies of the interpolation points. Hereby, 
%                opt.initialParams(1:end-1,k) contains the k-th initial
%                parameter value and opt.initialParams(end,k) contains the
%                corresponding initial frequency. The vectors 
%                opt.initialParams(1:end-1,k) must be in D for each k.
%
if isfield( opt, 'initialParams' )
    paraminit = opt.initialParams;
else
    error( 'The argument opt.initialParams must be specified.' );
end
%
% initialFreqs: initial frequencies of the initial interpolation
%                   points on the imaginary axis used for computing the
%                   H-infinity norm by linorm_subsp.
%
if isfield( opt, 'initialFreqs' )
    freqinit = opt.initialFreqs;
else
    error( 'The argument opt.initialFreqs must be specified.' );
end
%
% maxSing: specifies how the projection spaces are constructed.
%
if isfield( opt, 'maxSing' )
    if opt.maxSing == 0 || opt.maxSing == 1
        maxSing = opt.maxSing;
    else
        error( 'The argument opt.maxSing must be 0 or 1.' );
    end
else % default
    maxSing = 0;
end
%
% biorth: specifies the orthonormalization scheme.
%
if isfield( opt, 'biorth' )
    if opt.biorth == 0 || opt.biorth == 1
        biorth = opt.biorth;
    else
        error( 'The argument opt.biorth must be 0 or 1.' );
    end
else % default
    biorth = 0;
end
%
% orthtol: relative truncation tolerance in svd for the determination of an
%          orthonormal basis of a subspace or biorthonormal bases of two 
%          subspaces.
%
if isfield( opt, 'orthtol' )
    orthtol = opt.orthtol;
else % default
    orthtol = 1e-12;
end
%
% prtlevel: specifies the print level.
%
if isfield( opt, 'prtlevel' )
    prtlevel = opt.prtlevel;
    if ( prtlevel ~= 0 && prtlevel ~= 1 && prtlevel ~= 2 )
        error( 'The argument opt.prtlevel must be 0, 1, or 2.' );
    end
else % default
    prtlevel = 0;
end
%
% Check the dimensions of the inputs.
%
if iscell( sys.A )
    [ na1, na2 ] = size( sys.A{ 1 } );
else
    [ na1, na2, ~ ] = size( sys.A );
end
%
if iscell( sys.B )
    [ n1, m ] = size( sys.B{ 1 } );
else
    [ n1, m, ~ ] = size( sys.B );
end
%
if iscell( sys.C )
    [ p, n2 ] = size( sys.C{ 1 } );
else
    [ p, n2, ~ ] = size( sys.C );
end
%
if iscell( sys.E )
    [ ne1, ne2 ] = size( sys.E{ 1 } );
else
    [ ne1, ne2, ~ ] = size( sys.E );
end
%
if n1 ~= n2
    error( 'The dimensions of A, B, C, and E are not compatible.' );
end
%
if ne1 ~= ne2
    error( 'The matrix E must be square.' );
elseif na1 ~= na2
    error( 'The matrix A must be square.' );
elseif ne1 ~= na1
    error( 'The dimensions of E and A are not compatible.' );
elseif ne1 ~= n1
    error( [ 'The dimensions of E and A are not compatible with B, ', ...
            'and C.' ] );
end
%
% Check the initial data for consistency.
%
ninit = size( paraminit, 2 );
dimD = size( paraminit, 1 ) - 1;
lenlb = length( sys.bounds.lb );
lenub = length( sys.bounds.ub );
%
if lenlb ~= lenub
    error( [ 'The dimensions of the bounds in sys.bounds.lb and ', ...
        'sys.bounds.ub are not compatible.' ] );
elseif lenlb ~= dimD
    error( [ 'The dimensions of the bounds in sys.bounds are not ', ...
        'compatible with the input data.' ] );
end
%
for j = 1:lenlb
    if sys.bounds.lb( j ) > sys.bounds.ub( j )
        error( [ 'sys.bounds.lb is not elementwise lower or equal to', ...
            'sys.bounds.ub.' ] )
    end
    %
    for k = 1:ninit
        if paraminit( j, k ) < sys.bounds.lb( j ) || ...
                paraminit( j, k ) > sys.bounds.ub( j )
            error( [ 'One of the initial parameter points is not in ', ...
                'the box domain D.' ] );
        end
    end
end
%
%% INITIALIZATIONS.
%
% Initialize the projection matrices.
%
if maxSing
    V = zeros( na1, ninit );
    U = zeros( na1, ninit );
else
    V = zeros( na1, ninit*min( m, p ) );
    U = zeros( na1, ninit*min( m, p ) );
end
%
for j = 1:ninit
    w = paraminit( end, j );
    [ Amu, Bmu, Cmu, Emu ] = evalTF( sys, paraminit( 1:end-1, j ) );
    %
    if maxSing
        %
        % Compute the maximum singular value of H(i*w;μ) and construct a
        % subspace from the corresponding singular vectors.
        %
        [ U1, ~, V1 ] = svd( full( Cmu*( ( 1i*w*Emu-Amu )\Bmu ) ) );
        V( :, j ) = ( 1i*w*Emu-Amu )\( Bmu*V1( :, 1 ) );
        U( :, j ) = ( 1i*w*Emu-Amu )'\( Cmu'*U1( :, 1 ) );
    else
        % 
        % Solve the linear systems to construct an initial subspace with 
        % the desired interpolation property.
        %
        X = ( 1i*w*Emu-Amu )\Bmu;
        Y = ( 1i*w*Emu-Amu )'\Cmu'; 
        %
        % Compare the input dimension m and output dimension p to make the 
        % subspaces U and V have the same dimension.
        %
        if m == p
            V( :, ( j-1 )*m+1:j*m ) = X;
            U( :, ( j-1 )*p+1:j*p ) = Y;
        elseif m < p                 
            V( :, ( j-1 )*m+1:j*m ) = X;
            U( :, ( j-1 )*m+1:j*m ) = Y*( Cmu*X );
        else
            V( :, ( j-1 )*p+1:j*p ) = X*( Bmu'*Y );
            U( :, ( j-1 )*p+1:j*p ) = Y;
        end
    end
end
%
% For later computations we need real projection matrices, so transform
% U and V to real matrices.
%
V = [ real( V ), imag( V ) ];
U = [ real( U ), imag( U ) ];
% 
% Construct orthonormal or biorthonormal bases for the subspaces
% given by U and V.
%
[ U, U2 ] = orthnorm( U, orthtol );
[ V, V2 ] = orthnorm( V, orthtol );
nu = size( U, 2 );
nv = size( V, 2 );
%
if nu > nv
    d = nu - nv;
    V = [ V, V2( :, 1:d ) ];
elseif nv > nu
    d = nv - nu;
    U = [ U, U2( :, 1:d ) ];
end
%
if biorth
    %
    % Construct biorthonormal bases. 
    %
    [ U, V ] = biorthnorm( U, V, orthtol );
end
%
%% SOLVE THE INITIAL REDUCED PROBLEM.
%
% Reduce the system by U and V.
%
redsys = reduceParamSystem( sys, U, V );
redsys.method = boydbalak;
%
% Minimize the H-infinity norm of the reduced system. 
%
if optmeth == 0
    %
    % Use GRANSO.
    %
    if prtlevel > 0
        %
        % Print info.
        %
        fprintf( 'Use GRANSO for the optimization.\n' );
    end
    %
    % Construct a function handle for the objective function.
    %
    objfun = @( mu )feval( redsys.fgname, mu, redsys );
    %
    % Construct a function handle for the inequality constraints.
    %
    constrfun = @( mu )feval( 'gransoConstr', mu, redsys );
    %
    % Set GRANSO options.
    %
    optgranso.x0 = 0.5*( sys.bounds.lb + sys.bounds.ub );
    optgranso.quadprog_info_msg = false;
    optgranso.opt_tol = 1e-12;
    optgranso.print_level = 0;
    solgranso = granso( lenlb, @( mu )objfun( mu ), ...
        @( mu )constrfun( mu ), [ ], optgranso );
    mumin = solgranso.final.x;
else
    %
    % Use eigopt.
    %
    if prtlevel > 0
        %
        % Print info.
        %
        fprintf( 'Use eigopt for the optimization.\n' );
    end
    redsys.tol = 1e-8;
    redsys.gamma = gamma;
    [ ~, mumin ] = eigopt( redsys.fgname, redsys.bounds, redsys );
end
%
% Set the options for linorm_subsp (to compute the H-infinity norm).
%
optlinorm.tolz = tolmu;
optlinorm.tolf = tolnorm;
optlinorm.initialPoints = freqinit;
optlinorm.prtlevel = max( prtlevel - 1, 0 );
optlinorm.boydbalak = boydbalak;
optlinorm.biorth = biorth;
optlinorm.orthtol = orthtol;
optlinorm.maxSing = maxSing;                  
%
% Evaluate the H-infinity norm of the full-order model at the optimal
% parameter mu for the reduced system.
%
[ sysmu.A, sysmu.B, sysmu.C, sysmu.E ] = evalTF( sys, mumin );
sysmu.D = zeros( p, m );
sysmu.method = 1;
%
if prtlevel > 1
    %
    % Print info.
    %
    fprintf( 'Computing the H-infinity norm by linorm_subsp: \n' );
end
%
[ hinfnmin, freqmin, ~ ] = linorm_subsp( sysmu, optlinorm );
optlinorm.initialPoints = [ freqinit, freqmin ];
%
if prtlevel > 0
    %
    % Print info.
    %
    [ ~, subSize ] = size( V );
    fprintf( 'Current outer iteration: 0 \t Current minimizer: [ ' );
    fprintf( '%.6f ', mumin );
    fprintf( [ '] \t H-infinity norm: %.6f \t Subspace dimension: %i ', ...
        '\n' ], hinfnmin, subSize )
end
%
%% MAIN LOOP.
%
% Run the algorithm until the relative accuracy or the maximum number of 
% iterations is reached.
%
% Initializations.
%
iter = 0;
hinfnminold = -1e16;
muminold = -1e16*ones( lenlb, 1 );
%
while abs( hinfnmin - hinfnminold ) > tolnorm*( 0.5*( abs( hinfnmin ) + ...
        abs( hinfnminold ) ) ) && norm( mumin - muminold, 2 ) > tolmu*...
        ( 0.5*( norm( mumin, 2 ) + norm( muminold, 2 ) ) ) && iter < maxit
    iter = iter + 1;
    hinfnminold = hinfnmin;
    muminold = mumin;
    %
    % Expand the projection spaces.
    %
    if maxSing
        %
        % Compute the maximum singular value of H(i*w;μ) and construct a
        % subspace from the corresponding singular vectors.
        %
        [ U1, ~, V1 ] = svd( full( sysmu.C*( ( 1i*freqmin*sysmu.E ...
            -sysmu.A )\sysmu.B ) ) );
        Viter = ( 1i*freqmin*sysmu.E-sysmu.A )\( sysmu.B*V1( :, 1 ) );
        Uiter = ( 1i*freqmin*sysmu.E-sysmu.A )'\( sysmu.C'*U1( :, 1 ) );
    else
        %
        % Solve the linear systems to construct a subspace with the 
        % desired interpolation property.
        %
        X = ( 1i*freqmin*sysmu.E-sysmu.A )\sysmu.B;
        Y = ( 1i*freqmin*sysmu.E-sysmu.A )'\sysmu.C'; 
        %
        % Compare the input dimension m and output dimension p to make
        % the subspaces U and V have the same dimension.
        %
        if m == p
            Viter = X;
            Uiter = Y;
        elseif m < p                 
            Viter = X;
            Uiter = Y*( sysmu.C*X );
        else
            Viter = X*( sysmu.B'*Y );
            Uiter = Y;
        end
    end
    %
    % For later computations we need real projection matrices, so transform
    % U and V to real matrices.
    %
    Viter = [ real( Viter ), imag( Viter ) ];
    Uiter = [ real( Uiter ), imag( Uiter ) ];
    %
    % Update the projection spaces.
    %
    V = [ V, Viter ];
    U = [ U, Uiter ];
    % 
    % Construct orthonormal or biorthonormal bases for the subspaces
    % given by U and V.
    %
    [ U, U2 ] = orthnorm( U, orthtol );
    [ V, V2 ] = orthnorm( V, orthtol );
    nu = size( U, 2 );
    nv = size( V, 2 );
    %
    if nu > nv
        d = nu - nv;
        V = [ V, V2( :, 1:d ) ];
    elseif nv > nu
        d = nv - nu;
        U = [ U, U2( :, 1:d ) ];
    end
    %
    if biorth
        %
        % Construct biorthonormal bases. 
        %
        [ U, V ] = biorthnorm( U, V, orthtol );
    end
    %
    % Reduce the system by U and V.
    %
    redsys = reduceParamSystem( sys, U, V ); 
    redsys.method = boydbalak;
    %
    % Minimize the H-infinity norm of the reduced system. 
    %
    if optmeth == 0
        %
        % Use GRANSO.
        %
        % Construct a function handle for the objective function.
        %
        objfun = @( mu )feval( redsys.fgname, mu, redsys );
        %
        % Construct a function handle for the inequality constraints.
        %
        constrfun = @( mu )feval( 'gransoConstr', mu, redsys );
        %
        % Set GRANSO options.
        %
        optgranso.x0 = mumin;
        solgranso = granso( lenlb, @( mu )objfun( mu ), ...
            @( mu )constrfun( mu ), [ ], optgranso );
        mumin = solgranso.final.x;
    else
        %
        % Use eigopt.
        %
        redsys.tol = 1e-8;
        redsys.gamma = gamma;
        [ ~, mumin ] = eigopt( redsys.fgname, redsys.bounds, redsys );
    end
    %
    % Evaluate the full system and its infinity norm at the parameter mu.
    %
    [ sysmu.A, sysmu.B, sysmu.C, sysmu.E ] = evalTF( sys, mumin );
    sysmu.D = zeros( p, m );
    %
    if prtlevel > 1
        %
        % Print info.
        %
        fprintf( 'Computing the H-infinity norm by linorm_subsp: \n' );
    end
    %
    [ hinfnmin, freqmin, ~ ] = linorm_subsp( sysmu, optlinorm );
    optlinorm.initialPoints = [ optlinorm.initialPoints, freqmin ];
    %               
    if prtlevel > 0
        %
        % Print info.
        %
        [ ~, subSize ] = size( V );
        fprintf( [ 'Current outer iteration: %i \t Current ', ...
            'minimizer: [ ' ], iter );
        fprintf( '%.6f ', mumin );
        fprintf( [ '] \t H-infinity norm: %.6f \t Subspace ', ...
            'dimension: %i \n' ], hinfnmin, subSize );
    end  
end
%
%% STORE THE OUTPUTS.
%
info.time = toc( timehinfopt );
info.iterations = iter;
info.finaltolmu = norm( mumin-muminold, 2 )/( 0.5*( norm( mumin, 2 ) + ...
    norm( muminold, 2 ) ) );
info.finaltolnorm = abs( hinfnmin-hinfnminold )/...
    ( 0.5*( abs( hinfnmin ) + abs( hinfnminold ) ) );
%
if iter >= maxit    
    info.error = 1;
    if ( prtlevel > 1 )
        %
        % Print info.
        %
        warning( [ 'The algorithm has terminated by reaching the ', ...
            'maximum number of iterations.' ] );
    end
end
%
% Check which of the termination criteria are satisfied.
%
if norm( mumin-muminold, 2 ) < tolmu*( 0.5*( norm( mumin, 2 ) + ...
        norm( muminold, 2 ) ) ) && abs( hinfnmin-hinfnminold ) < ...
        tolnorm*( 0.5*( abs( hinfnmin ) + abs( hinfnminold ) ) )
    %
    % Both the optimal parameter mumin and the optimal H-infinity norm
    % hinfnmin have converged.
    %
    info.termcrit = 0;
    %
    if prtlevel > 1
        %
        % Print info.
        %
        fprintf( [ 'Both the optimal parameter and the optimal ', ...
            'H-infinity norm have converged.\n' ] );
    end
elseif norm( mumin-muminold, 2 ) < tolmu*( 0.5*( norm( mumin,2 ) + ...
        norm( muminold, 2 ) ) )
    %
    % Only the optimal parameter mumin has converged, but the optimal
    % H-infinity norm hinfnmin may be inaccurate.
    %
    info.termcrit = 1;
    %
    if prtlevel > 1
        %
        % Print info.
        %
        fprintf( [ 'The optimal parameter has converged, but the ', ...
            'optimal H-infinity norm may be inaccurate.\n' ] );
     end
elseif abs( hinfnmin-hinfnminold ) < tolnorm*( 0.5*( abs( hinfnmin ) + ...
        abs( hinfnminold ) ) )
    %
    % Only the optimal H-infinity norm hinfnmin has converged, but the
    % optimal parameter mumin may be inaccurate.
    %
    info.termcrit = 2;
    %
    if prtlevel > 1
        %
        % Print info.
        %
        fprintf( [ 'The optimal H-infinity norm has converged, but ', ...
            'the optimal parameter may be inaccurate.\n' ] );
    end
else
    %
    % The algorithm has terminated by reaching the maximum number of
    % iterations.
    %
    info.termcrit = 3;
end
%
if prtlevel > 0
    %
    % Print info.
    %
    fprintf( 'The optimal parameter is attained for mumin = [ ' );
    fprintf( '%.6f ', mumin );
    fprintf( ']. The optimal H-infinity norm is %g.\n', hinfnmin );
    fprintf( 'The runtime is %g seconds.\n', info.time );
end
%
return